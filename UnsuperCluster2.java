package secubase_c;

import weka.clusterers.ClusterEvaluation;
import weka.clusterers.EM;
import weka.core.*;
import weka.core.converters.CSVSaver;
import weka.core.converters.ConverterUtils.DataSource;

import java.io.File;
import java.util.StringTokenizer;

import weka.filters.*;
import weka.filters.unsupervised.attribute.AddCluster;
import weka.filters.unsupervised.attribute.NumericToNominal;
import weka.filters.unsupervised.attribute.Remove;
public class UnsuperCluster2 {

	public void clustererCSV2(String input, String output) throws Exception { //input에 전처리 된 데이터 입력 // output -> 결과파일
		 
		  String In_path = input;
		  String Out_path = output;
		
		  DataSource source = new DataSource(In_path);
		  Instances data = source.getDataSet();
		  if (data.classIndex() == -1)
		 	data.setClassIndex(data.numAttributes() - 1);

		  Remove remove = new Remove();  
		  String[] options0 = weka.core.Utils.splitOptions("-R last"); //class 칼럼 제외
	      remove.setOptions(options0);
	      remove.setInputFormat(data); 
		
		  AddCluster clusterer = new AddCluster(); // EM 알고리즘 적용
		  String[] options = weka.core.Utils.splitOptions("-W \"weka.clusterers.EM -I 100 -N 2 -M 1.0E-6 -S 100\"");
		  clusterer.setOptions(options);  
		  clusterer.setInputFormat(data);
		  
		  Instances resultData = Filter.useFilter(data, clusterer);

		  CSVSaver saver = new CSVSaver();
		  saver.setInstances(resultData);
		  saver.setFile(new File(Out_path));
		  saver.writeBatch();

	}
	
	public void unsupermeasure(String input) throws Exception {
		 
		  String In_path = input;
		
		  DataSource source = new DataSource(In_path);
		  Instances olddata = source.getDataSet();
		  if (olddata.classIndex() == -1)
		 	olddata.setClassIndex(olddata.numAttributes() - 1);

		  NumericToNominal convert= new NumericToNominal(); //class 명사화
		     String[] optionc= new String[2];
		     optionc[0]="-R";
		     optionc[1]="last";  //range of variables to make numeric

		     convert.setOptions(optionc);
		     convert.setInputFormat(olddata);

		     Instances data=Filter.useFilter(olddata, convert);
			  
			 // generate data for clusterer (w/o class)
			 Remove filter = new Remove();
			 filter.setAttributeIndices("" + (data.classIndex() + 1));
			 filter.setInputFormat(data);
			 Instances dataClusterer = Filter.useFilter(data, filter);
			
			 String[] options = weka.core.Utils.splitOptions("-I 100 -N 2 -M 1.0E-6 -S 100");

			 
			 // train clusterer
			 EM clusterer = new EM();
			 clusterer.setOptions(options);  
			 
			 clusterer.buildClusterer(dataClusterer);
			 

			 
			 // evaluate clusterer
			 ClusterEvaluation eval = new ClusterEvaluation();
			 eval.setClusterer(clusterer);
			 eval.evaluateClusterer(data);

			 String cutString = eval.clusterResultsToString();
		                               
			 String stringCoupon = "    0    1  <-- assigned to cluster";
			    						
			 int io_coupon = cutString.indexOf(stringCoupon);
			 
			 System.out.println("cutString "+ cutString);
			 System.out.println("io_coupon "+ io_coupon);
			 String coupon;
			 coupon = cutString.substring(io_coupon);

			String coupon_new1= coupon.substring((coupon.indexOf("to cluster\n")+12), (coupon.indexOf(" | 0")));
			String coupon_new2= coupon.substring((coupon.indexOf(" | 0\n")+6), (coupon.indexOf(" | 1")));
			String coupon_new3= coupon.substring((coupon.indexOf("Incorrectly clustered instances :")));
			
			StringTokenizer st1 = new StringTokenizer(coupon_new1," ");
			
			int count = 0;
			int tn_1 = 0;
			int fn_1 = 0;
			while(st1.hasMoreTokens()) {
				if(count==0) {
					String str = st1.nextToken();
					tn_1= Integer.parseInt(str);
				}
				else
					fn_1= Integer.parseInt(st1.nextToken());
				count++;
			}
			StringTokenizer st2 = new StringTokenizer(coupon_new2," ");
						
			count = 0;
			int fp_1 = 0;
			int tp_1 = 0;
			while(st2.hasMoreTokens()) {
				if(count==0)
					fp_1= Integer.parseInt(st2.nextToken());
				else
					tp_1= Integer.parseInt(st2.nextToken());
				count++;
			}
			
			double precision = (double)tp_1 / (double)(tp_1+fp_1);
			
			double recall = (double)tp_1 / (double)(tp_1+fn_1);
			
			double accurancy = (double)(tp_1+tn_1) / (double)(tp_1+tn_1+fp_1+fn_1);
			
			double trueNegativeRate = (double)tn_1 / (double)(tn_1+fp_1);

			double fmeasure = (2*precision*recall) / (precision+recall);
	/*			*/		
			double precision2 = (double)tn_1 / (double)(tn_1+fn_1);
			
			double recall2 = (double)tn_1 / (double)(tn_1+fp_1);
			
			double accurancy2 = (double)(tp_1+tn_1) / (double)(tp_1+tn_1+fp_1+fn_1);
			
			double trueNegativeRate2 = (double)tp_1 / (double)(tp_1+fn_1);
			
			double fmeasure2 = (2*precision2*recall2) / (precision2+recall2);

			System.out.println("/////////////////////////");
			System.out.println("MALWARE=TN");
			System.out.format("precision : %.4f%n", precision2);
			System.out.format("recall : %.4f%n", recall2);
			System.out.format("accurancy : %.4f%n", accurancy2);
			System.out.format("fmeasure : %.4f%n", fmeasure2);
			System.out.println();
			
			System.out.println("/////////////////////////");
			System.out.println("tp "+ tp_1 + " fp " + fp_1);
			System.out.println("fn "+ fn_1 + " tn " + tn_1);
			System.out.println(coupon_new3);


	}
 
	
	public void unsupercluster2(String input, String output) throws Exception {
		 
		unsupermeasure(input);
		clustererCSV2(input, output);
		 

	}
	


}